package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strings"
)

//ServiceFile contains the per file service declerations
type ServiceFile struct {
	Package  string
	Services map[string]ServiceDecl
}

//ServiceDecl is a generated interface grpc interface
type ServiceDecl struct {
	Procedures map[string]ProcedureDecl
}

//ProcedureDecl is a remote procedure on the service
type ProcedureDecl struct {
	InputDecl  *ast.Ident
	OutputDecl *ast.Ident
}

func parseProcedureSignature(logs *log.Logger, ftype *ast.FuncType) (p ProcedureDecl, err error) {
	if len(ftype.Params.List) != 2 {
		return p, fmt.Errorf("service procedure should have two parameters, got: %d", len(ftype.Results.List))
	}

	//first param is expected to be context, grab the second:
	if inputPtr, ok := ftype.Params.List[1].Type.(*ast.StarExpr); ok {
		if inputIdent, ok := inputPtr.X.(*ast.Ident); ok {
			p.InputDecl = inputIdent
		}
	}

	if p.InputDecl == nil {
		return p, fmt.Errorf("failed to parse procedure input decl from token '%v'", ftype)
	}

	if len(ftype.Results.List) != 2 {
		return p, fmt.Errorf("service procedure should have two return values, got: %d", len(ftype.Results.List))
	}

	//second result is always error, grab the first
	if outputPtr, ok := ftype.Results.List[0].Type.(*ast.StarExpr); ok {
		if outputIdent, ok := outputPtr.X.(*ast.Ident); ok {
			p.OutputDecl = outputIdent
		}
	}

	if p.OutputDecl == nil {
		return p, fmt.Errorf("failed to parse procedure output decl from token '%v'", ftype)
	}

	return p, nil
}

func parseServiceInterface(logs *log.Logger, itype *ast.InterfaceType) (s ServiceDecl, err error) {
	s.Procedures = map[string]ProcedureDecl{}
	for _, m := range itype.Methods.List {
		if len(m.Names) < 1 {
			continue
		}

		if ftype, ok := m.Type.(*ast.FuncType); ok {
			s.Procedures[m.Names[0].Name], err = parseProcedureSignature(logs, ftype)
			if err != nil {
				return s, fmt.Errorf("failed to parce procedure signature: %v", err)
			}
		}
	}

	return s, nil
}

func parse(logs *log.Logger, fset *token.FileSet, path string) (svcf *ServiceFile, err error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %v", err)
	}

	defer f.Close()
	astf, err := parser.ParseFile(fset, "", f, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file: %v", err)
	}

	ast.FilterFile(astf, func(s string) bool {
		if !strings.HasSuffix(s, "Server") {
			return false //fitler out all decl that dont end with "Server"
		}

		return true
	})

	svcf = &ServiceFile{
		Package:  astf.Name.Name,
		Services: map[string]ServiceDecl{},
	}

	ast.Inspect(astf, func(node ast.Node) bool {
		decl, ok := node.(*ast.GenDecl)
		if !ok || decl.Tok != token.TYPE {
			return true //we care only about types
		}

		for _, spec := range decl.Specs {
			if tspec, ok := spec.(*ast.TypeSpec); ok {
				if itype, ok := tspec.Type.(*ast.InterfaceType); ok {
					name := strings.TrimSuffix(tspec.Name.Name, "Server")

					svcf.Services[name], err = parseServiceInterface(logs, itype)
					if err != nil {
						err = fmt.Errorf("failed to parse service interface: %v", err)
						return false
					}
				}
			}
		}

		return true
	})

	if err != nil {
		return nil, err
	}

	return svcf, nil
}

var t = template.Must(template.New("gw").Parse(`// Code generated by protoc-gw-gen. DO NOT EDIT.

package {{.Package}}

import (
	"bytes"
	"context"
	"fmt"
	"mime"
	"net/http"
	"net/url"

	"github.com/golang/protobuf/jsonpb"
	"github.com/gorilla/schema"
)
{{range $n, $svc := .Services}}
//{{$n}}Caller makes it easy to request from a server that runs the http1.1 handler
type {{$n}}Caller struct {
	client *http.Client
	m      *jsonpb.Marshaler
	ep     *url.URL
}

//New{{$n}}Caller sets up the requester
func New{{$n}}Caller(c *http.Client, ep string) (r *{{$n}}Caller, err error) {
	r = &{{$n}}Caller{client: c, m: &jsonpb.Marshaler{}}
	r.ep, err = url.Parse(ep)
	if err != nil {
		return nil, fmt.Errorf("failed to parse endpoint for client: %v", err)
	}

	return r, nil
}

//{{$n}}Handler serves a gRPC interface on a http1.1 handler
type {{$n}}Handler struct {
	svc 				{{$n}}Server
	m   				*jsonpb.Marshaler
	FormDecoder *schema.Decoder
}

//New{{$n}}Handler can be used to serve gRPC over http1.1 servers
func New{{$n}}Handler(svc {{$n}}Server) *{{$n}}Handler {
	return &{{$n}}Handler{
		svc: 				 svc,
		m:   				 &jsonpb.Marshaler{},
		FormDecoder: schema.NewDecoder(),
	}
}
{{range $pn, $proc := $svc.Procedures}}
//Call{{$pn}} will call the remote procedure
func (r *{{$n}}Caller) Call{{$pn}}(ctx context.Context, m, p string, i *{{$proc.InputDecl.Name}}) (o *{{$proc.OutputDecl.Name}}, err error) {
	ref, err := url.Parse(p)
	if err != nil {
		return nil, fmt.Errorf("failed to parse call path '%s': %v", p, err)
	}

	var body *bytes.Buffer
	if i != nil {
		body = bytes.NewBuffer(nil)
		err = r.m.Marshal(body, i)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal input: %v", err)
		}
	}

	uri := r.ep.ResolveReference(ref)
	req, err := http.NewRequest(m, uri.String(), body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to perform request: %v", err)
	}

	o = &{{$proc.OutputDecl.Name}}{}
	defer resp.Body.Close()
	err = jsonpb.Unmarshal(resp.Body, o)
	if err != nil {
		return nil, fmt.Errorf("failed to decode JSON response body: %s", err)
	}

	return o, nil
}

//Handle{{$pn}} Is a generated handler that calls a gRPC service procedure
func (s *{{$n}}Handler) Handle{{$pn}}(w http.ResponseWriter, r *http.Request) {
	in := &{{$proc.InputDecl.Name}}{}

	err := r.ParseForm()
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to parse URL query or form body: %s", err), http.StatusBadRequest)
		return
	}

	if len(r.Form) > 0 {
		err = s.FormDecoder.Decode(in, r.Form)
		if err != nil {
			http.Error(w, fmt.Sprintf("failed to parse form schema: %s", err), http.StatusBadRequest)
			return
		}
	}

	mt, _, _ := mime.ParseMediaType(r.Header.Get("content-type"))

	defer r.Body.Close()
	if r.Body != nil && r.ContentLength != 0  && mt == "application/json" {
		err = jsonpb.Unmarshal(r.Body, in)
		if err != nil {
			http.Error(w, fmt.Sprintf("invalid request body: %s", err), http.StatusBadRequest)
			return
		}
	}

	out, err := s.svc.{{$pn}}(r.Context(), in)
	if err != nil {
		http.Error(w, fmt.Sprintf("request failed: %s", err), http.StatusInternalServerError)
		return
	}

	err = s.m.Marshal(w, out)
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to create response: %s", err), http.StatusInternalServerError)
		return
	}
}
{{end}}{{end}}
`))

func write(logs *log.Logger, path string, svcf *ServiceFile) error {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to open output file: %v", err)
	}

	defer f.Close()

	err = t.Option("missingkey=error").Execute(f, svcf)
	if err != nil {
		return fmt.Errorf("failed to execute generator template: %v", err)
	}

	return nil
}

func run(logs *log.Logger, args []string) error {
	if len(args) < 1 {
		log.Fatal("usage: gg <pb.gofiles>")
	}
	wdir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %v", err)
	}

	fset := token.NewFileSet()
	for _, rel := range args {
		path := filepath.Join(wdir, rel)
		if strings.Contains(path, ".gw") {
			continue
		}

		services, err := parse(logs, fset, path)
		if err != nil {
			return fmt.Errorf("failed to generate: %v", err)
		}

		if len(services.Services) < 1 {
			continue //skip generation of files that contain no services
		}

		nparts := strings.SplitN(filepath.Base(path), ".", 2)
		nparts[0] = nparts[0] + ".gw"
		gwfname := strings.Join(nparts, ".")
		gwfpath := filepath.Join(filepath.Dir(path), gwfname)

		//@TODO provide hooks before (and after?) body marshalling that allow customizing the mapping of
		//request (headers) to the protobuf fields OR provide implementation access to original request through
		//context value?
		//@TODO provide hooks for customizing the grpc response to HTTP response code/message
		//@TODO provide a way to generate API docs
		//@TODO generate handler documentation for niceness in godoc
		//@TODO test the case in which there are no services in a proto file
		//@TODO think about how to determine to response type (start with just JSON, or also form?)
		//@TODO can we encode errors from the service implementation, preferrably allow users to specify
		//an application specific error message in the proto files
		//@TODO use table tests
		//@TODO test how it handles streaming rpcs endpoints
		//@TODO test how form decoding handles all kinds of protobuf possibilities (excoting types, nested structs etc)
		//@TODO set response content type in handlers
		//@TODO generate a client that asserts reponse codes?
		//@TODO generate a client that takes into account response content type?
		//@TODO figure out if we can always assume we can we always assume we have a body with json? empty bodies?
		//@TODO find out if we assert mandatory endpoint elemements upon caller constructing

		err = write(logs, gwfpath, services)
		if err != nil {
			return fmt.Errorf("failed to write output: %v", err)
		}
	}

	return nil
}

func main() {
	err := run(log.New(os.Stderr, "gwgen/", log.Lshortfile), os.Args[1:])
	if err != nil {
		log.Fatal(err)
	}

}
