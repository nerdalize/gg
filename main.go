package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strings"
)

//ServiceFile contains the per file service declerations
type ServiceFile struct {
	Package  string
	Services map[string]ServiceDecl
}

//ServiceDecl is a generated interface grpc interface
type ServiceDecl struct {
	Procedures map[string]ProcedureDecl
}

//ProcedureDecl is a remote procedure on the service
type ProcedureDecl struct {
	InputDecl  *ast.Ident
	OutputDecl *ast.Ident
}

func parseProcedureSignature(logs *log.Logger, ftype *ast.FuncType) (p ProcedureDecl, err error) {
	if len(ftype.Params.List) != 2 {
		return p, fmt.Errorf("service procedure should have two parameters, got: %d", len(ftype.Results.List))
	}

	//first param is expected to be context, grab the second:
	if inputPtr, ok := ftype.Params.List[1].Type.(*ast.StarExpr); ok {
		if inputIdent, ok := inputPtr.X.(*ast.Ident); ok {
			p.InputDecl = inputIdent
		}
	}

	if p.InputDecl == nil {
		return p, fmt.Errorf("failed to parse procedure input decl from token '%v'", ftype)
	}

	if len(ftype.Results.List) != 2 {
		return p, fmt.Errorf("service procedure should have two return values, got: %d", len(ftype.Results.List))
	}

	//second result is always error, grab the first
	if outputPtr, ok := ftype.Results.List[0].Type.(*ast.StarExpr); ok {
		if outputIdent, ok := outputPtr.X.(*ast.Ident); ok {
			p.OutputDecl = outputIdent
		}
	}

	if p.OutputDecl == nil {
		return p, fmt.Errorf("failed to parse procedure output decl from token '%v'", ftype)
	}

	return p, nil
}

func parseServiceInterface(logs *log.Logger, itype *ast.InterfaceType) (s ServiceDecl, err error) {
	s.Procedures = map[string]ProcedureDecl{}
	for _, m := range itype.Methods.List {
		if len(m.Names) < 1 {
			continue
		}

		if ftype, ok := m.Type.(*ast.FuncType); ok {
			s.Procedures[m.Names[0].Name], err = parseProcedureSignature(logs, ftype)
			if err != nil {
				return s, fmt.Errorf("failed to parce procedure signature: %v", err)
			}
		}
	}

	return s, nil
}

func parse(logs *log.Logger, fset *token.FileSet, path string) (svcf *ServiceFile, err error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %v", err)
	}

	defer f.Close()
	astf, err := parser.ParseFile(fset, "", f, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file: %v", err)
	}

	ast.FilterFile(astf, func(s string) bool {
		if !strings.HasSuffix(s, "Server") {
			return false //fitler out all decl that dont end with "Server"
		}

		return true
	})

	svcf = &ServiceFile{
		Package:  astf.Name.Name,
		Services: map[string]ServiceDecl{},
	}

	ast.Inspect(astf, func(node ast.Node) bool {
		decl, ok := node.(*ast.GenDecl)
		if !ok || decl.Tok != token.TYPE {
			return true //we care only about types
		}

		for _, spec := range decl.Specs {
			if tspec, ok := spec.(*ast.TypeSpec); ok {
				if itype, ok := tspec.Type.(*ast.InterfaceType); ok {
					name := strings.TrimSuffix(tspec.Name.Name, "Server")

					svcf.Services[name], err = parseServiceInterface(logs, itype)
					if err != nil {
						err = fmt.Errorf("failed to parse service interface: %v", err)
						return false
					}
				}
			}
		}

		return true
	})

	if err != nil {
		return nil, err
	}

	return svcf, nil
}

var t = template.Must(template.New("gw").Parse(`// Code generated by protoc-gw-gen. DO NOT EDIT.

package {{.Package}}

import (
	"fmt"
	"net/http"

	"github.com/gorilla/schema"
	"github.com/golang/protobuf/jsonpb"
)
{{range $n, $svc := .Services}}
//{{$n}}Handler serves a gRPC interface on a http1.1 handler
type {{$n}}Handler struct {
	svc {{$n}}Server
	m   *jsonpb.Marshaler
	dec *schema.Decoder
}

//New{{$n}}Handler can be used to serve gRPC over http1.1 servers
func New{{$n}}Handler(svc {{$n}}Server) *{{$n}}Handler {
	return &{{$n}}Handler{
		svc: svc,
		m:   &jsonpb.Marshaler{},
		dec: schema.NewDecoder(),
	}
}

//ServeHTTP implements the http.Handler interface
func (s *{{$n}}Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	//@TODO provide (default) routing of URL parts to handlers
}
{{range $pn, $proc := $svc.Procedures}}
//Handle{{$pn}} Is a generated handler that calls a gRPC service procedure
func (s *{{$n}}Handler) Handle{{$pn}}(w http.ResponseWriter, r *http.Request) {
	in := &{{$proc.InputDecl.Name}}{}

	defer r.Body.Close()
	err := jsonpb.Unmarshal(r.Body, in)
	if err != nil {
		http.Error(w, fmt.Sprintf("invalid request body: %s", err), http.StatusBadRequest)
		return
	}

	out, err := s.svc.{{$pn}}(r.Context(), in)
	if err != nil {
		http.Error(w, fmt.Sprintf("request failed: %s", err), http.StatusInternalServerError)
		return
	}

	err = s.m.Marshal(w, out)
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to create response: %s", err), http.StatusInternalServerError)
		return
	}
}
{{end}}{{end}}
`))

func write(logs *log.Logger, path string, svcf *ServiceFile) error {
	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to open output file: %v", err)
	}

	defer f.Close()

	err = t.Option("missingkey=error").Execute(f, svcf)
	if err != nil {
		return fmt.Errorf("failed to execute generator template: %v", err)
	}

	return nil
}

func run(logs *log.Logger, args []string) error {
	if len(args) < 1 {
		log.Fatal("usage: gg <pb.gofiles>")
	}
	wdir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %v", err)
	}

	fset := token.NewFileSet()
	for _, rel := range args {
		path := filepath.Join(wdir, rel)
		if strings.Contains(path, ".gw") {
			continue
		}

		services, err := parse(logs, fset, path)
		if err != nil {
			return fmt.Errorf("failed to generate: %v", err)
		}

		nparts := strings.SplitN(filepath.Base(path), ".", 2)
		nparts[0] = nparts[0] + ".gw"
		gwfname := strings.Join(nparts, ".")
		gwfpath := filepath.Join(filepath.Dir(path), gwfname)

		//@TODO add default routing based on url
		//@TODO provide hooks before (and after?) body marshalling that allow customizing the mapping of
		//requests to the protobuf input
		//@TODO provide hooks for customizing the grpc response to HTTP response code/message
		//@TODO provide ways to parse form values instead of body
		//@TODO provide a way to call gRPC remotes (via client)?
		//@TODO provide a way to generate docs
		//@TODO generate handler documentation for niceness in godoc

		err = write(logs, gwfpath, services)
		if err != nil {
			return fmt.Errorf("failed to write output: %v", err)
		}
	}

	return nil
}

func main() {
	err := run(log.New(os.Stderr, "gwgen/", log.Lshortfile), os.Args[1:])
	if err != nil {
		log.Fatal(err)
	}

}
